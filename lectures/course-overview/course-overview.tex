\documentclass{article}

\input{def}

\begin{document}
\maketitle

\begin{quote}
  ``A computer is simply an instrument whose music is ideas'' -Alan Kay, 2003\footnote{\url{http://www.scholastic.com/browse/article.jsp?id=5}}
\end{quote}

The goal of this course is the explain and support this quotation.
We will teach fundamental design and programming skills using the Coq proof assistant.

\subsection*{Target Audience}
This course targets students with at least one year of programming experience.
You should have some practice building small applications.
Experience in any language is fine, but a strong background in functional programming will subsume most material in the first third of the course.
On the other hand, if your only experience is with C or Java we recommend looking over the course prologue~\cite{TODO} to get a taste for the functional style before starting Lecture 1.

That said, we hope these notes are useful to a wider audience.
If you want to pick up a new language, and are interested in type-driven design and about formalizing proofs of correctness alongside your code, these notes are for you.
Rather than give a comprehensive summary of Coq (a task better left to Pierce and Chlipala~\cite{TODO}), we present ideas that should fit any programming context.

\subsection*{Topics Covered}
TBA

\subsection*{Topics not Covered}
Subject to change, but probably including:

\begin{center}
  \begin{tabular}{c c c c}
    Amortized Analysis & Complexity & Concurrency & Coinduction
  \\Data-Oriented Programming & & &
  \end{tabular}
\end{center}

\subsection*{Structure}
Our general problem-solving strategy will be:
\begin{enumerate}
\item Think about the essence of the problem, choose a datatype to model it.
\item Convince ourselves that we can solve the problem with psuedocode and an informal correctness proof.
\item Create a program realizing our ideas.
\item Create a formal proof of our program's correctness.
\end{enumerate}

Steps 1 and 2 are by far the most important and broadly applicable; however ideas are worth little until they can be implemented.
The order of steps 3 and 4 is guided by our choice of language.
There is a strong connection between formally proving a theorem and programming an algorithm, and these activities are best done simultaneously, but the ``prove, then program'' order seems to work best in Coq.

\subsection*{About Coq}
We will use the Coq programming language / proof assistant because it offers an expressive language for specifying problems and reasoning about correctness.
We can uniformly express a data model, algorithm, and proof of correctness in Coq.

\begin{center}
\begin{verbatim}
  Inductive data := ...
\end{verbatim}
\begin{verbatim}
  Fixpoint program : data -> data := ...
\end{verbatim}
\begin{verbatim}
  Theorem about_the_program : forall A, exists B ... 
  Proof. ...
\end{verbatim}
\end{center}

Furthermore, Coq interactively evaluates our definitions for basic syntactical and logical errors.
That said, Coq has problems.
Most of the above-listed ``topics not covered'' are omitted because Coq is not mature enough to handle them.
Despite its shortcomings and learning curve, we think Coq is a great tool for learning and well worth knowing.

\subsection*{Conventions}

The following are idiosyncrasies we use throughout the text.

\subsubsection*{Coffee Breaks}

We will sometimes write a small question on its own line, centered, and surrounded by flowers, like this:

\coffeebreak{Did you know that the Verranzano Bridge is 1,439 meters longer than the Golden Gate Bridge?}

These questions will be relevant to the text, and nearly always answered by the following paragraph.
We include them as an invitation to stand up, stretch, pour a cup of coffee, or gaze out a window.
Take a two-minute break and think about the question before going forward.

\end{document}
